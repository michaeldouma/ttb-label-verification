<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Batch Label Processor</title>
<link href="https://fonts.googleapis.com/css2?family=Source+Sans+3:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Source Sans 3', system-ui, sans-serif;
    font-size: 13px;
    color: #333;
    background: #faf8f4;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }

  /* ─── Demo header ─── */
  .demo-header {
    background: #6d1a6d;
    padding: 14px 24px;
    border-bottom: 1px solid #5a1458;
    flex-shrink: 0;
  }

  .demo-header .demo-title {
    font-size: 22px;
    font-weight: 700;
    color: #fff;
    flex: 1;
  }

  .demo-header .demo-row {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .demo-header .demo-actions {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    flex-shrink: 0;
  }

  /* ─── State toggle ─── */
  .state-toggle {
    display: flex;
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  }

  .state-toggle .state-btn {
    font-family: inherit;
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 0.05em;
    padding: 8px 14px;
    border: none;
    cursor: pointer;
    transition: all 0.15s;
    text-transform: uppercase;
  }

  .state-toggle .state-btn.running {
    background: rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.6);
  }
  .state-toggle .state-btn.running:hover {
    background: rgba(255,255,255,0.25);
    color: #fff;
  }
  .state-toggle .state-btn.running.active {
    background: linear-gradient(135deg, #27ae60 0%, #1e8449 100%);
    color: #fff;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
  }

  .state-toggle .state-btn.stopped {
    background: rgba(255,255,255,0.15);
    color: rgba(255,255,255,0.6);
  }
  .state-toggle .state-btn.stopped:hover {
    background: rgba(255,255,255,0.25);
    color: #fff;
  }
  .state-toggle .state-btn.stopped.active {
    background: linear-gradient(to bottom right, #e66000, #c4002c);
    color: #fff;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
  }

  .tap-icon {
    height: 140px;
    position: absolute;
    top: 50%;
    left: 20%;
    transform: translateX(-50%);
    pointer-events: none;
    z-index: 100;
    animation: bob 1.2s ease-in-out infinite;
    display: none; /* Hidden by default, parent controls visibility */
  }
  .tap-icon.visible { display: block; }
  @keyframes bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-4px); }
  }

  /* ─── Status bar ─── */
  .status-bar {
    background: #f5f3f0;
    border-bottom: 1px solid #e0ddd8;
    padding: 8px 24px;
    display: flex;
    align-items: center;
    gap: 24px;
    font-size: 12px;
    color: #666;
    flex-shrink: 0;
  }

  .status-bar .status-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .status-bar .status-label {
    color: #999;
  }

  .status-bar .status-value {
    font-weight: 600;
    color: #333;
  }

  .status-bar .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .status-bar .status-dot.green { background: #27ae60; box-shadow: 0 0 4px rgba(39, 174, 96, 0.5); }
  .status-bar .status-dot.yellow { background: #f39c12; box-shadow: 0 0 4px rgba(243, 156, 18, 0.5); }
  .status-bar .status-dot.red { background: #e74c3c; box-shadow: 0 0 4px rgba(231, 76, 60, 0.5); }

  .status-bar .sep {
    color: #ccc;
    margin: 0 4px;
  }

  /* ─── Metrics row ─── */
  .metrics-row {
    background: #fff;
    border-bottom: 1px solid #e0ddd8;
    padding: 12px 24px;
    display: flex;
    gap: 32px;
    flex-shrink: 0;
  }

  .metrics-row .metric {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .metrics-row .metric-value {
    font-size: 18px;
    font-weight: 700;
    color: #333;
  }

  .metrics-row .metric-label {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #999;
  }


  /* ─── Sparkline charts ─── */
  .throughput-section {
    background: #fff;
    border-bottom: 1px solid #e0ddd8;
    padding: 12px 24px;
    display: flex;
    gap: 32px;
    flex-shrink: 0;
  }

  .sparkline-container {
    flex: 1;
  }

  .sparkline-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .sparkline-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #999;
  }

  .sparkline-value {
    font-size: 12px;
    font-weight: 700;
    color: #333;
  }

  .sparkline {
    height: 32px;
    display: flex;
    align-items: flex-end;
    gap: 2px;
  }

  .sparkline .bar {
    flex: 1;
    background: linear-gradient(180deg, #6d1a6d 0%, #a855a8 100%);
    border-radius: 2px 2px 0 0;
    min-height: 2px;
    transition: height 0.3s;
  }

  .sparkline .bar:hover {
    background: linear-gradient(180deg, #8b2a8b 0%, #c077c0 100%);
  }

  /* ─── Two-column recent activity ─── */
  .recent-activity {
    display: flex;
    gap: 24px;
    padding: 16px 24px;
    overflow: hidden;
  }

  .recent-column {
    flex: 1;
    display: flex;
    flex-direction: column;
    max-height: 160px;
    background: #fff;
    border: 1px solid #e0ddd8;
    border-radius: 8px;
    overflow: hidden;
  }

  .recent-column-header {
    padding: 10px 14px;
    background: #f8f6f3;
    border-bottom: 1px solid #e0ddd8;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #666;
  }

  .recent-column-body {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
  }

  /* Recent completions - thumbnail grid */
  .completion-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .completion-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    cursor: pointer;
  }

  .completion-item img {
    width: 56px;
    height: 56px;
    border-radius: 4px;
    border: 1px solid #ddd;
    object-fit: cover;
    transition: transform 0.15s, box-shadow 0.15s;
  }

  .completion-item:hover img {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }

  .completion-item .ttb-id {
    font-size: 9px;
    color: #999;
    font-family: monospace;
  }

  .completion-item.new img {
    animation: newItem 0.6s ease-out;
  }

  @keyframes newItem {
    0% {
      transform: scale(0.5);
      opacity: 0;
      box-shadow: 0 0 0 4px rgba(39, 174, 96, 0.6);
    }
    50% {
      transform: scale(1.1);
      box-shadow: 0 0 0 8px rgba(39, 174, 96, 0.3);
    }
    100% {
      transform: scale(1);
      opacity: 1;
      box-shadow: 0 0 0 0 rgba(39, 174, 96, 0);
    }
  }

  /* Recent errors list */
  .error-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .error-item {
    display: flex;
    gap: 10px;
    padding: 8px 10px;
    background: #fef8f8;
    border: 1px solid #f5dede;
    border-radius: 6px;
    font-size: 11px;
  }

  .error-item .error-time {
    color: #999;
    flex-shrink: 0;
    font-variant-numeric: tabular-nums;
  }

  .error-item .error-id {
    font-family: monospace;
    color: #666;
    flex-shrink: 0;
  }

  .error-item .error-type {
    color: #c0392b;
    font-weight: 600;
  }

  .no-errors {
    color: #27ae60;
    font-size: 12px;
    padding: 20px;
    text-align: center;
  }

  .no-errors::before {
    content: '✓ ';
  }

  /* ─── Resize handle ─── */
  .resize-handle {
    height: 8px;
    background: #e8e5e0;
    cursor: ns-resize;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    user-select: none;
  }

  .resize-handle:hover {
    background: #ddd8d0;
  }

  .resize-handle::before {
    content: '';
    width: 40px;
    height: 3px;
    background: #c5c0b8;
    border-radius: 2px;
  }

  .resize-handle:active {
    background: #d5d0c8;
  }

  /* ─── Activity log ─── */
  .log-section {
    padding: 12px 24px;
    display: flex;
    flex-direction: column;
    background: #f5f3f0;
    min-height: 80px;
    height: 150px;
    flex-shrink: 0;
  }

  .log-heading {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #999;
    margin-bottom: 6px;
    flex-shrink: 0;
  }

  .log-box {
    flex: 1;
    overflow-y: auto;
    font-size: 11px;
    font-family: 'SF Mono', Monaco, 'Consolas', monospace;
    color: #666;
    line-height: 1.5;
  }
  .log-box::-webkit-scrollbar { width: 4px; }
  .log-box::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }

  .log-entry {
    display: flex;
    gap: 8px;
    padding: 2px 0;
  }

  .log-time {
    color: #999;
    flex-shrink: 0;
  }

  .log-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
    margin-top: 5px;
  }
  .log-dot.green { background: #27ae60; }
  .log-dot.blue { background: #3b5bdb; }
  .log-dot.red { background: #c0392b; }
  .log-dot.gray { background: #999; }
</style>
</head>
<body>

<div class="demo-header">
  <div class="demo-row">
    <div class="demo-title" id="headerTitle">Label Analyzer: Ready to Process</div>
    <div class="demo-actions">
      <div style="position:relative">
        <div class="state-toggle">
          <button class="state-btn running" id="btnRunning" onclick="startService()">Running</button>
          <button class="state-btn stopped active" id="btnStopped" onclick="stopService()">Stopped</button>
        </div>
        <img src="images/tapIcon.png" class="tap-icon" id="tapIcon" alt="tap">
      </div>
    </div>
  </div>
</div>

<!-- Status bar -->
<div class="status-bar">
  <div class="status-item">
    <span class="status-label">Uptime:</span>
    <span class="status-value" id="uptimeValue">Running for 14d 3h</span>
  </div>
  <span class="sep">|</span>
  <div class="status-item">
    <span class="status-dot green"></span>
    <span class="status-value">COLA Registry</span>
  </div>
  <span class="sep">|</span>
  <div class="status-item">
    <span class="status-dot green"></span>
    <span class="status-value">Anthropic API</span>
  </div>
  <span class="sep">|</span>
  <div class="status-item">
    <span class="status-label">Queue:</span>
    <span class="status-value" id="queueDepth">0</span>
  </div>
</div>

<!-- Metrics row -->
<div class="metrics-row">
  <div class="metric">
    <div class="metric-value" id="metricProcessed">0</div>
    <div class="metric-label">Done</div>
  </div>
  <div class="metric">
    <div class="metric-value" id="metricPending">0</div>
    <div class="metric-label">Pending</div>
  </div>
  <div class="metric">
    <div class="metric-value" id="metricRate">—</div>
    <div class="metric-label">Apps/Hour</div>
  </div>
  <div class="metric">
    <div class="metric-value" id="metricAvgTime">—</div>
    <div class="metric-label">Avg/App</div>
  </div>
  <div class="metric">
    <div class="metric-value" id="metricErrorRate">0%</div>
    <div class="metric-label">Errors (24h)</div>
  </div>
</div>

<!-- Throughput sparklines -->
<div class="throughput-section">
  <div class="sparkline-container">
    <div class="sparkline-header">
      <span class="sparkline-title">24h Activity</span>
      <span class="sparkline-value" id="spark24hTotal">0 processed</span>
    </div>
    <div class="sparkline" id="sparkline24h"></div>
  </div>
  <div class="sparkline-container">
    <div class="sparkline-header">
      <span class="sparkline-title">7d Activity</span>
      <span class="sparkline-value" id="spark7dTotal">0 processed</span>
    </div>
    <div class="sparkline" id="sparkline7d"></div>
  </div>
</div>

<!-- Two-column recent activity -->
<div class="recent-activity">
  <div class="recent-column">
    <div class="recent-column-header">Recent Completions</div>
    <div class="recent-column-body">
      <div class="completion-grid" id="completionGrid">
        <span style="color:#999; font-size:12px;">No completions yet</span>
      </div>
    </div>
  </div>
  <div class="recent-column">
    <div class="recent-column-header">Recent Errors</div>
    <div class="recent-column-body">
      <div class="error-list" id="errorList">
        <div class="no-errors">No errors in last 24h</div>
      </div>
    </div>
  </div>
</div>

<!-- Resize handle -->
<div class="resize-handle" id="resizeHandle"></div>

<!-- Activity log -->
<div class="log-section" id="logSection">
  <div class="log-heading">Activity Log</div>
  <div class="log-box" id="logBox"></div>
</div>

<script src="ttb-external/data/applications.js"></script>
<script>
const IMG_BASE = 'ttb-external/images/';
const STATS_URL = 'verification/stats.json';
const API_BASE = 'http://localhost:9081';

let apps = [];
let activityLog = [];
let stats = { summary: { totalProcessed: 0, totalPending: 0, totalErrors: 0 }, log: [] };
let serviceRunning = false;  // Service state: RUNNING or STOPPED
let isProcessing = false;    // Whether actively processing right now
let processingStartTime = null;
let processingStartCount = 0;
let processingEndTime = null;
let statsInterval = null;  // Polling interval ID
let previousCompletionIds = new Set();  // Track for new item animation

function ttbIdToShardPath(ttbId) {
  const digits = ttbId.slice(0, 8).split('');
  const remainder = ttbId.slice(8);
  return `ttb-external/data/applicant/${digits.join('/')}/${remainder}.json`;
}

async function init() {
  const lightweightApps = COLA_APPLICATIONS.map(a => ({
    ttbId: a.ttbId,
    classTypeCode: a.classTypeCode,
    brandName: null,
    fancifulName: null,
    frontImg: null,
    status: 'pending'
  }));

  apps = lightweightApps;

  // Fetch full data in parallel batches
  const batchSize = 10;
  for (let i = 0; i < lightweightApps.length; i += batchSize) {
    const batch = lightweightApps.slice(i, i + batchSize);
    await Promise.all(batch.map(async (app) => {
      try {
        const resp = await fetch(ttbIdToShardPath(app.ttbId));
        if (resp.ok) {
          const data = await resp.json();
          app.brandName = data.brandName;
          app.fancifulName = data.fancifulName;
          app.frontImg = data.labelImages?.front || null;
        }
      } catch (e) {}
    }));
  }

  await fetchStats();

  // Check if processing is already running (e.g., page was reloaded)
  try {
    const statusResp = await fetch(API_BASE + '/api/status');
    if (statusResp.ok) {
      const status = await statusResp.json();
      if (status.processing) {
        serviceRunning = true;
        isProcessing = true;
        processingStartTime = Date.now() - 10000; // Assume started recently
        processingStartCount = Math.max(0, (stats.summary.totalProcessed || 0) - 1);
        addLog('Reconnected to running service', 'blue');
        startPolling();
        pollProcessStatus();
      }
    }
  } catch (e) {
    // API server not running, that's OK
  }

  addLog('UI initialized', 'gray');
  initResizeHandle();
  render();
}

function startPolling() {
  if (statsInterval) return;  // Already polling
  statsInterval = setInterval(fetchStats, 3000);
}

function stopPolling() {
  if (statsInterval) {
    clearInterval(statsInterval);
    statsInterval = null;
  }
}

async function fetchStats() {
  try {
    const resp = await fetch(STATS_URL + '?t=' + Date.now());
    if (resp.ok) {
      stats = await resp.json();
      render();

      // If service is running but idle, check for new work
      if (serviceRunning && !isProcessing) {
        const pending = stats.summary.totalPending || 0;
        if (pending > 0) {
          checkAndProcess();
        }
      }
    }
  } catch (e) {
    console.debug('Stats not available:', e.message);
  }
}

function render() {
  const pending = stats.summary.totalPending || 0;
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);

  const processedEntries = (stats.log || []).filter(e => e.action === 'processed');
  const errorEntries = (stats.log || []).filter(e => e.action === 'error');
  const total = stats.summary.totalProcessed || processedEntries.length;
  const hasProcessed = total > 0 || processedEntries.length > 0;

  // Update header title based on state
  const headerTitle = document.getElementById('headerTitle');
  if (serviceRunning && isProcessing) {
    headerTitle.textContent = 'Label Processing Service — Processing';
  } else if (serviceRunning) {
    headerTitle.textContent = 'Label Processing Service — Running';
  } else {
    headerTitle.textContent = 'Label Processing Service — Stopped';
  }

  // Update queue depth in status bar
  document.getElementById('queueDepth').textContent = pending;

  // Update current state metrics (from summary, not log)
  document.getElementById('metricProcessed').textContent = stats.summary.totalProcessed || 0;
  document.getElementById('metricPending').textContent = pending;

  // Update throughput metrics (from log activity)
  const last24hProcessed = processedEntries.filter(e => new Date(e.timestamp) >= yesterday);
  const last24hErrors = errorEntries.filter(e => new Date(e.timestamp) >= yesterday);

  if (last24hProcessed.length > 0) {
    // Calculate rate and avg time
    const firstTime = new Date(last24hProcessed[last24hProcessed.length - 1].timestamp);
    const lastTime = new Date(last24hProcessed[0].timestamp);
    const spanHours = Math.max((lastTime - firstTime) / (1000 * 60 * 60), 0.1);
    const rate = Math.round(last24hProcessed.length / spanHours);
    const avgTime = Math.round(spanHours * 3600 / last24hProcessed.length);

    document.getElementById('metricRate').textContent = rate;
    document.getElementById('metricAvgTime').textContent = avgTime + 's';
  } else {
    document.getElementById('metricRate').textContent = '—';
    document.getElementById('metricAvgTime').textContent = '—';
  }

  const totalLast24h = last24hProcessed.length + last24hErrors.length;
  const errorRate = totalLast24h > 0 ? ((last24hErrors.length / totalLast24h) * 100).toFixed(1) : 0;
  document.getElementById('metricErrorRate').textContent = errorRate + '%';

  // Deduplicate log entries by TTB ID (keep first/most recent occurrence)
  const seenIds = new Set();
  const uniqueProcessed = processedEntries.filter(e => {
    if (seenIds.has(e.ttbId)) return false;
    seenIds.add(e.ttbId);
    return true;
  });

  // Update sparklines
  renderSparklines(uniqueProcessed);

  // Update recent completions grid (only if changed to avoid flicker)
  const completionGrid = document.getElementById('completionGrid');
  const recentProcessed = uniqueProcessed.slice(0, 12);
  const currentIds = new Set(recentProcessed.map(e => e.ttbId));
  const recentIds = recentProcessed.map(e => e.ttbId).join(',');

  if (completionGrid.dataset.ids !== recentIds) {
    completionGrid.dataset.ids = recentIds;

    if (recentProcessed.length > 0) {
      const recentApps = recentProcessed
        .map(e => ({ ...apps.find(a => a.ttbId === e.ttbId), ttbId: e.ttbId }))
        .filter(a => a.frontImg);

      completionGrid.innerHTML = recentApps.map(a => {
        const isNew = !previousCompletionIds.has(a.ttbId);
        return `
          <div class="completion-item${isNew ? ' new' : ''}" onclick="openInApp('${a.ttbId}')">
            <img src="${IMG_BASE}${a.frontImg}" alt="${a.brandName || ''}" loading="lazy">
            <span class="ttb-id">${a.ttbId.slice(-6)}</span>
          </div>
        `;
      }).join('') || '<span style="color:#999; font-size:12px;">No completions yet</span>';
    } else {
      completionGrid.innerHTML = '<span style="color:#999; font-size:12px;">No completions yet</span>';
    }

    // Update tracking set
    previousCompletionIds = currentIds;
  }

  // Update recent errors list (only if changed)
  const errorList = document.getElementById('errorList');
  const recentErrors = last24hErrors.slice(0, 5);
  const errorIds = recentErrors.map(e => e.ttbId + e.timestamp).join(',');

  if (errorList.dataset.ids !== errorIds) {
    errorList.dataset.ids = errorIds;

    if (recentErrors.length > 0) {
      errorList.innerHTML = recentErrors.map(e => {
        const time = new Date(e.timestamp).toLocaleTimeString('en-US',
          { hour: '2-digit', minute: '2-digit', hour12: false });
        return `
          <div class="error-item">
            <span class="error-time">${time}</span>
            <span class="error-id">${e.ttbId?.slice(-6) || '—'}</span>
            <span class="error-type">${e.message || 'Unknown error'}</span>
          </div>
        `;
      }).join('');
    } else {
      errorList.innerHTML = '<div class="no-errors">No errors in last 24h</div>';
    }
  }

  // State toggle - show service state (not processing state)
  document.getElementById('btnRunning').classList.toggle('active', serviceRunning);
  document.getElementById('btnStopped').classList.toggle('active', !serviceRunning);

  // Hide tap icon when service is running
  const tapIcon = document.getElementById('tapIcon');
  if (serviceRunning) {
    tapIcon.classList.remove('visible');
  }
}

function renderSparklines(processedEntries) {
  const now = new Date();

  // 24-hour sparkline (hourly buckets)
  const spark24h = document.getElementById('sparkline24h');
  const hourBuckets = new Array(24).fill(0);
  let total24h = 0;

  processedEntries.forEach(e => {
    const timestamp = new Date(e.timestamp);
    const hoursAgo = Math.floor((now - timestamp) / (1000 * 60 * 60));
    if (hoursAgo >= 0 && hoursAgo < 24) {
      hourBuckets[23 - hoursAgo]++;
      total24h++;
    }
  });

  const maxHour = Math.max(...hourBuckets, 1);
  spark24h.innerHTML = hourBuckets.map(count =>
    `<div class="bar" style="height: ${(count / maxHour) * 100}%" title="${count}"></div>`
  ).join('');
  document.getElementById('spark24hTotal').textContent = total24h + ' processed';

  // 7-day sparkline (daily buckets)
  const spark7d = document.getElementById('sparkline7d');
  const dayBuckets = new Array(7).fill(0);
  let total7d = 0;

  processedEntries.forEach(e => {
    const timestamp = new Date(e.timestamp);
    const daysAgo = Math.floor((now - timestamp) / (1000 * 60 * 60 * 24));
    if (daysAgo >= 0 && daysAgo < 7) {
      dayBuckets[6 - daysAgo]++;
      total7d++;
    }
  });

  const maxDay = Math.max(...dayBuckets, 1);
  spark7d.innerHTML = dayBuckets.map(count =>
    `<div class="bar" style="height: ${(count / maxDay) * 100}%" title="${count}"></div>`
  ).join('');
  document.getElementById('spark7dTotal').textContent = total7d + ' processed';
}

function addLog(msg, dotColor = 'gray') {
  const now = new Date();
  const time = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
  activityLog.unshift({ time, msg, dotColor });
  activityLog = activityLog.slice(0, 100);  // Keep last 100 entries
  renderLog();
}

// Resize handle functionality
function initResizeHandle() {
  const handle = document.getElementById('resizeHandle');
  const logSection = document.getElementById('logSection');
  const recentActivity = document.querySelector('.recent-activity');

  let isDragging = false;
  let startY = 0;
  let startLogHeight = 0;

  handle.addEventListener('mousedown', (e) => {
    isDragging = true;
    startY = e.clientY;
    startLogHeight = logSection.offsetHeight;
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const deltaY = startY - e.clientY;
    const newLogHeight = Math.max(80, Math.min(400, startLogHeight + deltaY));

    logSection.style.height = newLogHeight + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    }
  });
}

function renderLog() {
  const logBox = document.getElementById('logBox');
  if (!logBox) return;

  logBox.innerHTML = activityLog.map(entry => `
    <div class="log-entry">
      <span class="log-time">${entry.time}</span>
      <span class="log-dot ${entry.dotColor}"></span>
      <span>${entry.msg}</span>
    </div>
  `).join('');
}

async function forgetAll() {
  addLog('Forgetting all processing data...', 'blue');

  try {
    const resp = await fetch(API_BASE + '/api/clear', { method: 'POST' });
    const result = await resp.json();

    if (result.success) {
      addLog('Forgot all: ' + result.deletions.join(', '), 'green');
      // Reset all local state
      processingStartTime = null;
      processingStartCount = 0;
      processingEndTime = null;
      previousCompletionIds = new Set();
      // Clear the completion grid cache
      const completionGrid = document.getElementById('completionGrid');
      if (completionGrid) completionGrid.dataset.ids = '';
      const errorList = document.getElementById('errorList');
      if (errorList) errorList.dataset.ids = '';
      await fetchStats();
      // Notify parent that data was cleared
      window.parent.postMessage({ source: 'batch', action: 'cleared' }, '*');
    } else {
      addLog('Forget failed: ' + (result.stderr || 'Unknown error'), 'red');
    }
  } catch (e) {
    addLog('API error: ' + e.message + ' — is api_server.py running?', 'red');
  }
}

async function forget5() {
  addLog('Forgetting 5 random apps...', 'blue');

  // Clear completion grid immediately to avoid stale/duplicate display
  const completionGrid = document.getElementById('completionGrid');
  if (completionGrid) {
    completionGrid.dataset.ids = '';
    completionGrid.innerHTML = '<span style="color:#999; font-size:12px;">Refreshing...</span>';
  }

  try {
    const resp = await fetch(API_BASE + '/api/forget', { method: 'POST' });
    const result = await resp.json();

    if (result.success) {
      if (result.forgotten.length > 0) {
        addLog(`Forgot ${result.forgotten.length} apps: ${result.forgotten.join(', ')}`, 'green');
        addLog(`Now pending: ${result.now_pending}, still processed: ${result.remaining_processed}`, 'gray');
      } else {
        addLog('No processed apps to forget', 'gray');
      }
      await fetchStats();
    } else {
      addLog('Forget failed: ' + result.message, 'red');
    }
  } catch (e) {
    addLog('API error: ' + e.message + ' — is api_server.py running?', 'red');
  }
}

async function startService() {
  // Already running, ignore click
  if (serviceRunning) return;

  serviceRunning = true;
  addLog('Service started', 'green');
  startPolling();
  render();

  // If there's work, start processing
  await checkAndProcess();
}

async function checkAndProcess() {
  if (!serviceRunning || isProcessing) return;

  const pending = stats.summary.totalPending || 0;
  if (pending === 0) {
    addLog('Queue empty — waiting for work', 'gray');
    return;
  }

  addLog('Processing ' + pending + ' queued applications...', 'blue');
  isProcessing = true;
  lastSeenOutputIndex = 0;  // Reset so we capture all output from new process
  processingStartTime = Date.now();
  processingStartCount = stats.summary.totalProcessed || 0;
  processingEndTime = null;
  render();

  try {
    const resp = await fetch(API_BASE + '/api/process', { method: 'POST' });
    const result = await resp.json();

    if (result.success) {
      pollProcessStatus();
    } else {
      addLog('Processing failed: ' + result.message, 'red');
      isProcessing = false;
      render();
    }
  } catch (e) {
    addLog('API error: ' + e.message + ' — is api_server.py running?', 'red');
    isProcessing = false;
    render();
  }
}

let lastSeenOutputIndex = 0;

async function pollProcessStatus() {
  if (!isProcessing) return;

  try {
    const resp = await fetch(API_BASE + '/api/status');
    const result = await resp.json();

    // Show ALL new lines, not just the last one (so errors aren't lost)
    if (result.output?.length > 0) {
      for (let i = lastSeenOutputIndex; i < result.output.length; i++) {
        const line = result.output[i];
        if (line && !line.startsWith('Starting')) {
          const dotColor = line.includes('ERROR') ? 'red' :
                          line.includes('***') ? 'red' :
                          line.includes('Processing') ? 'blue' : 'gray';
          addLog(line, dotColor);
        }
      }
      lastSeenOutputIndex = result.output.length;
    }

    await fetchStats();

    if (result.processing) {
      setTimeout(pollProcessStatus, 2000);
    } else {
      // Processing batch finished
      isProcessing = false;
      processingEndTime = Date.now();

      const processed = (stats.summary.totalProcessed || 0) - processingStartCount;
      const elapsed = ((processingEndTime - processingStartTime) / 1000).toFixed(1);
      addLog(`Batch complete: ${processed} apps in ${elapsed}s`, 'green');

      // Notify parent that processing completed
      window.parent.postMessage({ source: 'batch', action: 'processingComplete' }, '*');

      // Stay in RUNNING mode if service is still on - just waiting for more work
      if (serviceRunning) {
        // Immediately check for new work (e.g., after Forget 5)
        await fetchStats();
        render();
      } else {
        stopPolling();
        render();
      }
    }
  } catch (e) {
    setTimeout(pollProcessStatus, 3000);
  }
}

async function stopService() {
  // Already stopped, ignore click
  if (!serviceRunning) return;

  addLog('Service stopped by admin', 'red');

  // If actively processing, abort it
  if (isProcessing) {
    try {
      const resp = await fetch(API_BASE + '/api/abort', { method: 'POST' });
      const result = await resp.json();
      if (!result.success) {
        addLog('Abort warning: ' + result.message, 'red');
      }
    } catch (e) {
      addLog('Abort error: ' + e.message, 'red');
    }
  }

  serviceRunning = false;
  isProcessing = false;
  processingEndTime = Date.now();
  stopPolling();
  await fetchStats();
  render();
}

function openInApp(ttbId) {
  const app = apps.find(a => a.ttbId === ttbId);
  const classTypeCode = app?.classTypeCode || '';
  window.parent.postMessage({ source: 'batch', action: 'openApp', ttbId, classTypeCode }, '*');
}

// Listen for messages from parent (tap icon control, clear all, forget 5)
window.addEventListener('message', (e) => {
  if (e.data && e.data.action === 'showTapIcon') {
    const tapIcon = document.getElementById('tapIcon');
    if (tapIcon) tapIcon.classList.toggle('visible', e.data.visible);
  } else if (e.data && e.data.action === 'forgetAll') {
    forgetAll();
  } else if (e.data && e.data.action === 'forget5') {
    forget5();
  }
});

init();
</script>
</body>
</html>
