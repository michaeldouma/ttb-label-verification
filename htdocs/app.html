<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Label Verification</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { height: 100%; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 13px;
    color: #1a1a2e;
    background: #f5f6f8;
    min-height: 100%;
  }

  /* â”€â”€â”€ Waiting state â”€â”€â”€ */
  .waiting {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    padding: 40px;
    text-align: center;
  }
  .waiting.hidden { display: none; }
  .waiting-icon {
    width: 64px;
    height: 64px;
    margin-bottom: 20px;
    opacity: 0.3;
  }
  .waiting h2 {
    font-size: 18px;
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
  }
  .waiting p {
    font-size: 14px;
    color: #666;
    max-width: 400px;
    line-height: 1.5;
  }
  .waiting .btn-hint {
    display: inline-block;
    margin-top: 16px;
    background: #4f5fff;
    color: #fff;
    font-size: 13px;
    font-weight: 600;
    padding: 8px 16px;
    border-radius: 6px;
  }

  /* â”€â”€â”€ Not processed state â”€â”€â”€ */
  .not-processed {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    padding: 40px;
    text-align: center;
  }
  .not-processed.visible { display: flex; }
  .not-processed-icon {
    font-size: 48px;
    margin-bottom: 16px;
    opacity: 0.5;
  }
  .not-processed h2 {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
  }
  .not-processed p {
    font-size: 13px;
    color: #666;
    max-width: 340px;
    line-height: 1.5;
  }
  .not-processed .batch-btn {
    margin-top: 16px;
    padding: 10px 20px;
    background: #4f5fff;
    color: #fff;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.15s;
  }
  .not-processed .batch-btn:hover {
    background: #4350e6;
  }

  /* â”€â”€â”€ Results â”€â”€â”€ */
  .results { display: none; padding: 0 0 40px; }
  .results.visible { display: block; }

  /* â”€â”€â”€ Header section â”€â”€â”€ */
  .result-header {
    margin-bottom: 20px;
    padding: 20px 24px 0;
  }
  .header-top {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 4px;
  }
  .header-left {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
  }
  .fanciful-name {
    font-size: 28px;
    font-weight: 700;
    color: #0f172a;
    line-height: 1.1;
  }
  .ttb-id {
    font-size: 12px;
    font-weight: 500;
    color: #94a3b8;
    white-space: nowrap;
  }
  .ttb-id span {
    font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    color: #64748b;
  }
  .reset-link {
    color: #94a3b8;
    text-decoration: underline;
    cursor: pointer;
  }
  .reset-link:hover {
    color: #64748b;
  }
  .product-type-pill {
    display: inline-block;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 4px 10px;
    border-radius: 20px;
    flex-shrink: 0;
  }
  .pill-wine, .pill-spirits, .pill-malt, .pill-other {
    background: #e5e7eb;
    color: #475569;
  }
  .origin-pill {
    display: inline-block;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 4px 10px;
    border-radius: 20px;
    flex-shrink: 0;
    background: #e5e7eb;
    color: #475569;
  }

  .brand-name {
    font-size: 13px;
    font-weight: 500;
    color: #64748b;
    margin-bottom: 16px;
  }

  /* â”€â”€â”€ Status banner â”€â”€â”€ */
  .status-banner {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    padding: 14px 24px;
    border-radius: 0;
    margin-bottom: 0;
    border-left: none;
    border-right: none;
    border-top: none;
  }
  .status-pass {
    background: linear-gradient(135deg, #064e3b 0%, #065f46 100%);
    border-bottom: 2px solid #047857;
  }
  .status-pass .status-icon { color: #6ee7b7; }
  .status-pass .status-text h3 { color: #ecfdf5; }
  .status-pass .status-count { color: #a7f3d0; }
  .status-fail {
    background: linear-gradient(135deg, #c2410c 0%, #ea580c 100%);
    border-bottom: 2px solid #f97316;
    padding: 18px 24px;
  }
  .status-fail .status-icon { color: #fed7aa; }
  .status-fail .status-text h3 { color: #fff7ed; }
  .status-fail .status-count { color: #fdba74; }
  .status-correct {
    background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
    border-bottom: 2px solid #dc2626;
  }
  .status-correct .status-icon { color: #fecaca; }
  .status-correct .status-text h3 { color: #fef2f2; }
  .status-correct .status-text p { color: #fecaca; }
  .status-correct .draft-label { color: #fecaca; }
  .status-correct .draft-content {
    border-color: #f87171;
    background: rgba(255,255,255,0.1);
    color: #fee2e2;
  }
  .status-correct .copy-btn {
    border-color: #f87171;
    color: #fee2e2;
    background: rgba(255,255,255,0.1);
  }
  .status-correct .copy-btn:hover:not(:disabled) { background: rgba(255,255,255,0.2); }
  .status-correct .copy-btn:active { background: rgba(255,255,255,0.3); }
  .status-correct .status-count { color: #fecaca; }
  .status-mixed {
    background: linear-gradient(135deg, #c2410c 0%, #ea580c 100%);
    border-bottom: 2px solid #f97316;
    padding: 18px 24px;
  }
  .status-mixed .status-icon { color: #fed7aa; }
  .status-mixed .status-text h3 { color: #fff7ed; }
  .status-mixed .status-text p { color: #fed7aa; }
  .status-mixed .status-count { color: #fdba74; }
  .status-mixed .draft-label { color: #fed7aa; }
  .status-mixed .draft-content {
    border-color: #fb923c;
    background: rgba(255,255,255,0.1);
    color: #fff7ed;
  }
  .status-mixed .draft-pending {
    color: #fed7aa;
    font-style: italic;
  }
  .status-left {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-shrink: 0;
  }
  .status-icon {
    font-size: 28px;
    line-height: 1;
  }
  .status-text h3 {
    font-size: 24px;
    font-weight: 700;
  }
  .status-text .status-count {
    font-size: 12px;
    font-weight: 500;
    margin-top: 2px;
  }
  .count-num {
    font-size: 2em;
    font-weight: 700;
    vertical-align: -0.15em;
  }

  /* Revision notes box */
  .draft-box {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: 10px;
    flex-shrink: 0;
  }
  .draft-sidebar {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
    flex-shrink: 0;
  }
  .draft-label {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    text-align: right;
    line-height: 1.3;
    color: #92400e;
  }
  .copy-btn {
    display: flex;
    align-items: center;
    gap: 4px;
    background: #fff;
    border: 1px solid #fcd34d;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    font-weight: 600;
    color: #92400e;
    cursor: pointer;
  }
  .copy-btn:hover:not(:disabled) { background: #fef3c7; }
  .copy-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .copy-btn svg { width: 14px; height: 14px; }
  .draft-pending {
    font-size: 11px;
    color: #92400e;
    font-style: italic;
  }
  .field-status {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 12px;
    color: #065f46;
    margin-top: 6px;
  }
  .field-status.missing {
    color: #b45309;
  }
  .verify-prompt {
    font-size: 11px;
    color: #92400e;
    font-style: italic;
  }
  .draft-content {
    background: #fff;
    border: 1px solid #fde68a;
    border-radius: 6px;
    padding: 8px 10px;
    font-size: 11px;
    color: #78350f;
    line-height: 1.5;
    max-height: 80px;
    max-width: 40vw;
    overflow-y: auto;
  }
  .status-pass .status-text p { color: #a7f3d0; }
  .status-fail .status-text p { color: #fde68a; }

  /* â”€â”€â”€ Review summary â”€â”€â”€ */
  .review-summary {
    font-size: 12px;
    color: #92400e;
    background: #fffbeb;
    border: 1px solid #fcd34d;
    border-radius: 6px;
    padding: 8px 12px;
    margin-bottom: 16px;
    line-height: 1.6;
  }

  /* â”€â”€â”€ Section dividers â”€â”€â”€ */
  .section-divider {
    border: none;
    border-top: 1px solid #e2e8f0;
    margin: 0 24px 2px;
  }
  .section-title {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #64748b;
    margin-bottom: 10px;
  }

  /* â”€â”€â”€ Mandatory elements section â”€â”€â”€ */
  .mandatory-section {
    margin-bottom: 20px;
    padding: 0 24px;
  }
  .mandatory-table {
    width: 100%;
    border-collapse: collapse;
    background: #fff;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    table-layout: fixed;
  }
  .mandatory-table th {
    font-size: 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    color: #9ca3af;
    background: #f8fafc;
    padding: 10px 12px;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
  }
  /* Match field-table column widths for grid alignment */
  .mandatory-table th:first-child,
  .mandatory-table td:first-child { width: 145px; }
  .mandatory-table th:nth-child(2),
  .mandatory-table td:nth-child(2) { width: calc((100% - 210px) / 2); }
  .mandatory-table th:nth-child(3),
  .mandatory-table td:nth-child(3) { width: calc((100% - 210px) / 2); }
  .mandatory-table th:nth-child(4),
  .mandatory-table td:nth-child(4) { width: 65px; text-align: center; }
  .mandatory-table td {
    padding: 12px;
    border-bottom: 1px solid #f1f5f9;
    vertical-align: middle;
  }
  .mandatory-table tr:last-child td { border-bottom: none; }
  .mandatory-table tr.row-warning { background: #fffbeb; }
  .mandatory-table tr.row-warning td { border-bottom-color: #fde68a; }
  .mandatory-table tr.row-mismatch { background: #fef2f2; }
  .mandatory-table tr.row-mismatch td { border-bottom-color: #fecaca; }
  .mandatory-table td:nth-child(2) .alert-note {
    margin-top: 6px;
  }
  .mandatory-table td:nth-child(3) {
    text-align: left;
  }
  .mandatory-table td:nth-child(3) .ocr-image {
    max-height: 48px;
    width: auto;
  }
  .mandatory-table td:nth-child(3) .verify-thumb {
    max-height: 48px;
    width: auto;
  }
  .mandatory-status {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 12px;
    color: #065f46;
  }
  .mandatory-status.missing {
    color: #b45309;
    font-weight: 600;
  }
  .mandatory-status.ai-ok,
  .field-status.ai-ok {
    color: #9ca3af;
  }
  .mandatory-status.rejected,
  .field-status.rejected {
    color: #dc2626;
  }
  .alert-note {
    font-size: 11px;
    color: #92400e;
    background: #fef3c7;
    border: 1px solid #fcd34d;
    border-radius: 4px;
    padding: 6px 8px;
    margin-top: 6px;
    line-height: 1.4;
  }
  .expected-value {
    font-size: 11px;
    color: #64748b;
    margin-bottom: 4px;
  }
  .field-warning {
    font-size: 10px;
    color: #b45309;
    background: #fef3c7;
    border: 1px solid #fcd34d;
    border-radius: 3px;
    padding: 4px 6px;
    margin-top: 4px;
    line-height: 1.3;
  }
  .manual-check-note {
    margin-top: 6px;
  }
  .manual-check-note a {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 11px;
    text-decoration: none;
    cursor: pointer;
  }
  .manual-check-note a:hover {
    text-decoration: underline;
  }
  .manual-check-note.verify-pending a { color: #b45309; }
  .manual-check-note.verify-ok a { color: #059669; }
  .manual-check-note.verify-issue a { color: #dc2626; }
  .manual-check-note.verify-ok .mandatory-status,
  .manual-check-note.verify-issue .mandatory-status { color: inherit; }
  .verify-thumb {
    height: 32px;
    width: auto;
    border-radius: 3px;
    border: 1px solid #d1d5db;
    opacity: 0.85;
  }
  .verify-thumb:hover {
    opacity: 1;
    border-color: #2563eb;
  }

  /* â”€â”€â”€ Field verification table â”€â”€â”€ */
  .fields-section {
    margin-bottom: 20px;
    padding: 0 24px;
  }

  .field-table {
    width: 100%;
    border-collapse: collapse;
    background: #fff;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    table-layout: fixed;
  }
  .field-table th {
    font-size: 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    color: #9ca3af;
    background: #f8fafc;
    padding: 10px 12px;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
  }
  .field-table th:first-child,
  .field-table td:first-child { width: 145px; }
  .field-table th:nth-child(2),
  .field-table td:nth-child(2) { width: calc((100% - 210px) / 2); }
  .field-table th:nth-child(3),
  .field-table td:nth-child(3) { width: calc((100% - 210px) / 2); }
  .field-table th:nth-child(4),
  .field-table td:nth-child(4) { width: 65px; text-align: center; }
  .field-table td { word-wrap: break-word; overflow-wrap: break-word; }

  /* Toggle buttons - horizontal under field name */
  .toggle-btns {
    display: flex;
    gap: 2px;
    font-size: 9px;
    font-weight: 600;
  }
  .toggle-btns button {
    border: none;
    background: #e5e7eb;
    color: #6b7280;
    padding: 2px 6px;
    border-radius: 3px;
    cursor: pointer;
  }
  .toggle-btns button:hover { background: #d1d5db; }
  .toggle-btns button.active { background: #10b981; color: #fff; }
  .toggle-btns button.active-reviewing { background: #f59e0b; color: #fff; }
  .toggle-btns button.active-correct { background: #ef4444; color: #fff; }

  /* Row status indicator */
  .row-status {
    text-align: center;
    line-height: 1;
  }
  .row-status .status-icon {
    font-size: 28px;
  }
  .row-status .ai-note {
    font-size: 8px;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    margin-top: 2px;
    white-space: nowrap;
    text-align: center;
  }
  td.row-status.status-flagged .status-icon,
  td.row-status.status-flagged .ai-note { color: #f59e0b; }
  td.row-status.status-ok .status-icon,
  td.row-status.status-ok .ai-note { color: #9ca3af; }
  td.row-status.status-corrected .status-icon,
  td.row-status.status-corrected .ai-note { color: #ef4444; }
  td.row-status.status-none .status-icon { color: #e5e7eb; }

  /* OCR cell - image above text */
  .ocr-cell {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }
  .ocr-image {
    max-width: 100%;
    max-height: 42px;
    border-radius: 4px;
    border: 1px solid #e2e8f0;
    object-fit: contain;
    display: block;
  }

  .field-table td {
    padding: 12px;
    border-bottom: 1px solid #f1f5f9;
    vertical-align: middle;
  }
  .field-table tr:last-child td { border-bottom: none; }

  .field-table tr.row-mismatch { background: #fef2f2; }
  .field-table tr.row-mismatch td { border-bottom-color: #fecaca; }

  /* Status cell */
  .status-cell {
    text-align: center;
    vertical-align: middle;
  }

  .field-table tr.row-warning { background: #fffbeb; }
  .field-table tr.row-warning td { border-bottom-color: #fde68a; }

  /* Field name cell */
  .field-cell {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .field-name {
    font-size: 14px;
    font-weight: 600;
    color: #334155;
  }

  /* Application value */
  .app-value {
    font-family: 'Times New Roman', Times, Georgia, serif;
    font-size: 13px;
    color: #1e293b;
  }

  .ocr-text {
    font-size: 12px;
    color: #1e293b;
    flex: 1;
    min-width: 0;
  }
  .ocr-text.mismatch {
    color: #dc2626;
  }
  /* â”€â”€â”€ Label images â”€â”€â”€ */
  .labels-section {
    padding: 0 24px;
    margin-bottom: 20px;
  }
  .labels-section h4 {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #64748b;
    margin-bottom: 10px;
  }
  .labels-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  .label-card {
    background: #fff;
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  }
  .label-card-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    color: #94a3b8;
    margin-bottom: 8px;
  }
  .label-card img {
    width: 100%;
    border-radius: 4px;
    border: 1px solid #e2e8f0;
  }
  .label-card .no-image {
    color: #94a3b8;
    font-size: 12px;
    font-style: italic;
    padding: 30px 10px;
    text-align: center;
    background: #f8fafc;
    border-radius: 4px;
  }

  /* â”€â”€â”€ Footer â”€â”€â”€ */
  .footer {
    font-size: 11px;
    color: #94a3b8;
    text-align: center;
    padding: 20px 24px 0;
    margin: 0 24px;
    border-top: 1px solid #e2e8f0;
  }

  /* â”€â”€â”€ Lightbox â”€â”€â”€ */
  .zoomable { cursor: zoom-in; }
  #lightbox {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.75);
    z-index: 1000;
    align-items: center;
    justify-content: center;
    cursor: zoom-out;
  }
  #lightbox.open { display: flex; }
  #lightbox img {
    min-width: 200px;
    min-height: 150px;
    max-width: 90vw;
    max-height: 85vh;
    border-radius: 6px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    background: #fff;
    padding: 4px;
    object-fit: contain;
  }
  .lightbox-container {
    position: relative;
    display: inline-block;
  }
  .lightbox-close {
    position: absolute;
    top: -12px;
    right: -12px;
    width: 32px;
    height: 32px;
    background: #fff;
    border: none;
    border-radius: 50%;
    font-size: 22px;
    line-height: 1;
    color: #333;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    z-index: 1;
  }
  .lightbox-close:hover {
    background: #f0f0f0;
  }
</style>
</head>
<body>

<div class="waiting" id="waitingState">
  <svg class="waiting-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
  </svg>
  <h2>Ready to Review</h2>
  <p>Select an application in the Agent View, then click</p>
  <div class="btn-hint">Verify Label Images</div>
</div>

<div class="not-processed" id="notProcessedState">
  <div class="not-processed-icon">ðŸ“‹</div>
  <h2>One More Step</h2>
  <p>This application's label images haven't been processed yet. Run the batch processor to extract text from the labels.</p>
  <button class="batch-btn" onclick="window.parent.postMessage({action: 'switchToBatch'}, '*')">Go to Batch Process</button>
</div>

<div class="results" id="results"></div>

<div id="lightbox" onclick="closeLightbox()">
  <div class="lightbox-container" onclick="event.stopPropagation()">
    <button class="lightbox-close" onclick="closeLightbox()">&times;</button>
    <img id="lb-img" src="" alt="">
  </div>
</div>

<script>
// TTB External API (simulated) â€” applicant data, label images
const TTB_IMG_BASE = 'ttb-external/images/';
const TTB_API_BASE = 'ttb-external/data/';

// Our Verification API â€” AI results, cropped field images
const VERIFICATION_BASE = 'verification/';

// Build sharded path for TTB external API (applicant data)
function getTtbShardedPath(ttbId) {
  const prefix = ttbId.slice(0, 8).split('').join('/');
  const suffix = ttbId.slice(8);
  return `${TTB_API_BASE}applicant/${prefix}/${suffix}.json`;
}

// Build sharded path for verification results JSON
function getVerificationResultPath(ttbId) {
  const prefix = ttbId.slice(0, 8).split('').join('/');
  const suffix = ttbId.slice(8);
  return `${VERIFICATION_BASE}results/${prefix}/${suffix}.json`;
}

// Build path for extracted field image (PNG file, not base64)
function getExtractionImagePath(ttbId, fieldName) {
  const prefix = ttbId.slice(0, 8).split('').join('/');
  const suffix = ttbId.slice(8);
  return `${VERIFICATION_BASE}extractions/${prefix}/${suffix}/${fieldName}.png`;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MANDATORY PRESENCE CHECKS
// These elements must appear on label but are NOT entered in COLA form.
// We just verify they're present, not match against applicant data.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Detect if product is imported based on originCode
// Reference: TTB origin codes (see private/work/reference/)
// Domestic codes: 00 (American), 01-49 (states), 4A (Puerto Rico),
//                 4B (Virgin Islands US), 4E (Alaska), 4K (DC)
// Everything else is foreign/imported
const DOMESTIC_ORIGIN_CODES = new Set([
  '00', '01', '02', '03', '04', '05', '06', '07', '08', '09',
  '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
  '20', '21', '22', '23', '24', '25', '26', '27', '28', '29',
  '30', '31', '32', '33', '34', '35', '36', '37', '38', '39',
  '40', '41', '42', '43', '44', '45', '46', '47', '48', '49',
  '4A', '4B', '4E', '4K',  // Puerto Rico, Virgin Islands US, Alaska, DC
]);

function isImportedProduct(originCode) {
  if (!originCode) return false;
  return !DOMESTIC_ORIGIN_CODES.has(originCode.toUpperCase());
}

// Extract country name from originDesc (e.g., "France" from "FR - France")
function getCountryName(originDesc) {
  if (!originDesc) return '';
  // originDesc format is typically "CODE - Name" or just the name
  const match = originDesc.match(/^[A-Z]{2}\s*[-â€”]\s*(.+)$/i);
  return match ? match[1].trim() : originDesc.trim();
}

function getMandatoryChecks(category, appData) {
  const checks = [
    // Government Warning â€” required on ALL beverages â‰¥0.5% ABV
    { key: 'governmentWarning', label: 'Government Warning' },
  ];

  // Contains Sulfites â€” required if â‰¥10ppm (27 CFR 4.32, 5.63, 7.63)
  // Applies to ALL categories, but wine is most common since sulfites are
  // routinely used in winemaking. For spirits/malt, sulfites are rare.
  // If present on label â†’ compliant (declaring sulfites)
  // If NOT present â†’ agent must check for sulfite waiver (lab report proving <10ppm)
  if (category === 'wine') {
    checks.push({
      key: 'sulfites',
      label: 'Contains Sulfites',
      alertIfMissing: '"Contains Sulfites" not seen. Verify visually. If no sulfite statement on label, check for sulfite waiver attachment.',
    });
  }

  // Country of Origin â€” imports only (customs/CBP requirement)
  // Domestic products (state codes like "05") don't need country of origin
  // Imported products (country codes like "FR") must show country on label
  if (isImportedProduct(appData.originCode)) {
    const countryName = getCountryName(appData.originDesc);
    checks.push({
      key: 'countryOfOrigin',
      label: 'Country of Origin',
      expectedValue: countryName,  // The country we expect to find on label
    });
  }

  return checks;
}

// Check if a mandatory element is detected in the extraction data
// expectedValue is used for country of origin to verify the correct country
function checkMandatoryElement(key, fields, expectedValue = null) {
  // Government Warning: check if text starts with "GOVERNMENT WARNING:"
  if (key === 'governmentWarning') {
    const text = fields.governmentWarning?.text || '';
    return text.toUpperCase().startsWith('GOVERNMENT WARNING:');
  }

  // Contains Sulfites: look for sulfite declaration in label text
  // Multiple acceptable formats per TTB regulations
  if (key === 'sulfites') {
    const sulfitePatterns = [
      /contains?\s*(sulfites?|sulphites?)/i,
      /contains?\s*(a\s*)?sulfiting\s*agent/i,
      /naturally\s*occur+ing\s*sulfites?/i,
    ];
    const testText = (text) => sulfitePatterns.some(p => p.test(text));

    // Check dedicated sulfites field first
    if (fields.sulfites?.text && testText(fields.sulfites.text)) {
      return true;
    }
    // Fall back to checking governmentWarning ocrText (full back label OCR)
    const ocrText = fields.governmentWarning?.ocrText || '';
    return testText(ocrText);
  }

  // Country of Origin: verify the expected country name appears on label
  // expectedValue is passed from getMandatoryChecks (e.g., "France")
  if (key === 'countryOfOrigin') {
    const text = fields.countryOfOrigin?.text || '';
    if (!text) return false;
    // If we have an expected country name, verify it matches
    if (expectedValue) {
      const normalizedText = text.toLowerCase().replace(/[^a-z]/g, '');
      const normalizedExpected = expectedValue.toLowerCase().replace(/[^a-z]/g, '');
      return normalizedText.includes(normalizedExpected);
    }
    return text.length > 0;
  }

  // Default: check if field exists and has text
  const fieldData = fields[key] || {};
  return !!fieldData.text;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIELD VERIFICATION CONFIG
// These are declared-vs-label matches: compare what applicant entered to what's on label.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getFieldConfig(category) {
  // Common fields for all beverage types
  const common = {
    brandName: { label: 'Brand Name', order: 1 },
    fancifulName: { label: 'Fanciful Name', order: 2, optional: true },
    classTypeDesc: { label: 'Class/Type', order: 3 },
    alcoholContent: { label: 'Alcohol Content', order: 4 },
    netContents: { label: 'Net Contents', order: 5 },
    bottlerName: { label: 'Bottler/Producer', order: 100 },
    bottlerAddress: { label: 'City, State', order: 101 },
  };

  // Wine-specific fields
  // Note: If vintage OR varietal is declared, appellation becomes REQUIRED
  if (category === 'wine') {
    return {
      ...common,
      wineVintage: { label: 'Vintage', order: 6, optional: true },
      grapeVarietal: { label: 'Grape Varietal', order: 7, optional: true },
      wineAppellation: { label: 'Appellation', order: 8, optional: true },
    };
  }

  // Distilled spirits fields
  if (category === 'spirits') {
    return {
      ...common,
      ageStatement: { label: 'Age Statement', order: 6, optional: true },
    };
  }

  // Malt beverages fields (alcohol content optional for malt)
  if (category === 'malt') {
    return {
      ...common,
      alcoholContent: { label: 'Alcohol Content', order: 4, optional: true },
    };
  }

  // Default/other
  return common;
}

// Global state for current verification
let currentAppData = null;
let currentVerificationData = null;
let currentChecks = [];

// Issue explanation generator - returns { shortDesc, fullDesc }
function generateIssueExplanation(field, appValue, ocrValue) {
  if (field === 'brandName') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The brand name on the label ("${ocrValue}") does not match the application ("${appValue}"). Please ensure the label and application match exactly.`
    };
  }
  if (field === 'fancifulName') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The fanciful name on the label ("${ocrValue}") does not match the application ("${appValue}").`
    };
  }
  if (field === 'alcoholContent') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The alcohol content on the label ("${ocrValue}") does not match the application ("${appValue}"). Please correct the label or application so they match.`
    };
  }
  if (field === 'netContents') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The net contents on the label ("${ocrValue}") does not match the application ("${appValue}"). If net contents are embossed on the container, please note this in Step 3 of your application.`
    };
  }
  if (field === 'qualifications') {
    return {
      shortDesc: `Government warning or required text may not match`,
      fullDesc: `The qualifications or required statements do not match the application. Please verify all mandatory text is present and matches.`
    };
  }
  if (field === 'classTypeDesc') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The class/type on the label ("${ocrValue}") does not match the application ("${appValue}").`
    };
  }
  if (field === 'wineVintage') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The vintage date on the label ("${ocrValue}") does not match the application ("${appValue}").`
    };
  }
  if (field === 'grapeVarietal') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The grape varietal on the label ("${ocrValue}") does not match the application ("${appValue}").`
    };
  }
  if (field === 'wineAppellation') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The appellation on the label ("${ocrValue}") does not match the application ("${appValue}"). Note: appellation is required when vintage or varietal is shown.`
    };
  }
  if (field === 'originDesc') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The country of origin on the label ("${ocrValue}") does not match the application ("${appValue}").`
    };
  }
  if (field === 'ageStatement') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The age statement on the label ("${ocrValue}") does not match the application ("${appValue}").`
    };
  }
  if (field === 'bottlerName') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The bottler/producer name on the label ("${ocrValue}") does not match the application ("${appValue}"). If using a DBA or trade name, it must be entered in the DBA/Trade Name field.`
    };
  }
  if (field === 'bottlerAddress') {
    return {
      shortDesc: `Label shows "${ocrValue}" vs submitted "${appValue}"`,
      fullDesc: `The bottler/producer address on the label ("${ocrValue}") does not match the application ("${appValue}"). At minimum, city and state must appear on the label.`
    };
  }
  return {
    shortDesc: `Mismatch detected`,
    fullDesc: `This field on the label does not match the application.`
  };
}

// Determine product category from class/type code
// Reference: work/reference/ttb-class-type-codes.txt
// Wine: 80-89, Spirits: 100-799, Malt: 900-999
function getProductCategory(classTypeCode) {
  if (!classTypeCode) return { name: 'Other', class: 'pill-other', key: 'other' };
  const code = parseInt(classTypeCode, 10);
  if (code >= 80 && code < 90) return { name: 'Wine', class: 'pill-wine', key: 'wine' };
  if (code >= 900 && code < 1000) return { name: 'Malt Beverage', class: 'pill-malt', key: 'malt' };
  if (code >= 100 && code < 800) return { name: 'Distilled Spirits', class: 'pill-spirits', key: 'spirits' };
  return { name: 'Other', class: 'pill-other', key: 'other' };
}

// Update status banner and draft box based on current toggle states
function updateDraftBox() {
  if (!currentAppData) return;

  const statusBanner = document.querySelector('.status-banner');
  const statusIcon = document.querySelector('.status-icon');
  const statusH3 = document.querySelector('.status-text h3');
  const statusCount = document.getElementById('statusCount');
  const draftBox = document.getElementById('draftBox');
  const draftAction = document.getElementById('draftAction');
  const draftText = document.getElementById('draftText');

  // Count field verification states
  let fieldReviewingCount = 0;
  let fieldRejectCount = 0;
  let fieldOkCount = 0;
  const rejectedFields = [];

  for (const check of currentChecks) {
    const storeKey = `review_${currentAppData.ttbId}_${check.key}`;
    const state = localStorage.getItem(storeKey) || (check.match ? 'ok' : 'reviewing');

    if (state === 'reviewing') {
      fieldReviewingCount++;
    } else if (state === 'reject') {
      fieldRejectCount++;
      rejectedFields.push({ type: 'field', ...check });
    } else {
      fieldOkCount++;
    }
  }

  // Count mandatory element states
  let mandatoryReviewingCount = 0;
  let mandatoryRejectCount = 0;
  let mandatoryOkCount = 0;
  const rejectedMandatory = [];

  document.querySelectorAll('.mandatory-table tr[data-field]').forEach(row => {
    const field = row.dataset.field;
    const storeKey = `review_${currentAppData.ttbId}_${field}`;
    const aiFlagged = row.querySelector('.row-status')?.dataset.aiFlagged === 'true';
    const state = localStorage.getItem(storeKey) || (aiFlagged ? 'reviewing' : 'ok');
    const label = row.querySelector('.field-name')?.textContent || field;

    if (state === 'reviewing') {
      mandatoryReviewingCount++;
    } else if (state === 'reject') {
      mandatoryRejectCount++;
      rejectedMandatory.push({ type: 'mandatory', key: field, label });
    } else {
      mandatoryOkCount++;
    }
  });

  const totalReviewingCount = fieldReviewingCount + mandatoryReviewingCount;
  const totalRejectCount = fieldRejectCount + mandatoryRejectCount;
  const totalOkCount = fieldOkCount + mandatoryOkCount;
  const totalFields = currentChecks.length + document.querySelectorAll('.mandatory-table tr[data-field]').length;

  // Determine overall status and update banner
  if (totalOkCount === totalFields) {
    // All verified OK
    statusBanner.className = 'status-banner status-pass';
    statusIcon.textContent = 'âœ“';
    statusH3.textContent = 'Label Verified';
    if (statusCount) statusCount.textContent = 'Ready to approve';
    if (draftBox) draftBox.style.display = 'none';
  } else if (totalReviewingCount === 0 && totalRejectCount > 0) {
    // All reviewed, issues confirmed - applicant needs to fix
    statusBanner.className = 'status-banner status-correct';
    statusIcon.textContent = '';
    statusH3.textContent = 'Issues Identified';
    if (statusCount) statusCount.innerHTML = `<span class="count-num">${totalRejectCount}</span> item${totalRejectCount > 1 ? 's' : ''} for applicant`;
    if (draftBox) draftBox.style.display = 'flex';
  } else if (totalReviewingCount > 0 && totalRejectCount > 0) {
    // Mixed state - some for applicant, some still for agent to verify
    statusBanner.className = 'status-banner status-mixed';
    statusIcon.textContent = 'âš ';
    statusH3.textContent = 'Verification in Progress';
    if (statusCount) statusCount.innerHTML = `<span class="count-num">${totalRejectCount}</span> issue${totalRejectCount > 1 ? 's' : ''} confirmed; <span class="count-num">${totalReviewingCount}</span> issue${totalReviewingCount > 1 ? 's' : ''} for agent to verify`;
    if (draftBox) draftBox.style.display = 'flex';  // Show draft, but copy button hidden
  } else {
    // Only potential issues, agent hasn't decided yet
    statusBanner.className = 'status-banner status-fail';
    statusIcon.textContent = 'âš ';
    statusH3.textContent = 'Verification in Progress';
    if (statusCount) statusCount.innerHTML = `<span class="count-num">${totalReviewingCount}</span> potential issue${totalReviewingCount > 1 ? 's' : ''} for agent to verify`;
    if (draftBox) draftBox.style.display = 'none';
  }

  // Update draft box content when there are rejected items
  if (draftAction && draftText && totalRejectCount > 0) {
    // Show copy button only when all reviewing is complete
    if (totalReviewingCount === 0) {
      draftAction.innerHTML = `
        <button class="copy-btn" onclick="copyDraftText()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          Copy
        </button>
      `;
    } else {
      // Still reviewing - hide copy button area
      draftAction.innerHTML = '';
    }

    // Build draft text from rejected fields AND mandatory elements
    const draftParts = [];

    // Add rejected mandatory elements
    for (const item of rejectedMandatory) {
      if (item.key.includes('governmentWarning')) {
        draftParts.push('The required Government Warning statement was not found on the label. This statement must appear on all alcoholic beverage containers.');
      } else if (item.key.includes('sulfites')) {
        draftParts.push('A "Contains Sulfites" statement was not found on the label. If the wine contains 10ppm or more sulfur dioxide, this declaration is required. If below 10ppm, please include laboratory analysis with your resubmission.');
      } else if (item.key.includes('countryOfOrigin')) {
        draftParts.push('A country of origin statement was not found on the label. Imported products must display country of origin (e.g., "Product of [Country]" or "Imported from [Country]").');
      }
    }

    // Add rejected field comparisons
    for (const check of rejectedFields) {
      const { fullDesc } = generateIssueExplanation(check.key, check.appValue, check.ocrValue);
      draftParts.push(fullDesc);
    }

    draftText.textContent = draftParts.join(' ');
  }
}

// Normalize text for comparison (case-insensitive)
function normalizeText(text) {
  if (!text) return '';
  return text.toLowerCase().replace(/[^a-z0-9]/g, '');
}

// Strip bottler/importer prefixes for comparison
// Per TTB rules: "Imported by", "Bottled by", "Produced by", etc. are prefixes
const BOTTLER_PREFIXES = [
  'imported by', 'imported and bottled by', 'sole agent', 'sole u.s. agent',
  'sole us agent', 'bottled by', 'produced and bottled by', 'distilled by',
  'produced by', 'blended by', 'made by', 'vinted by', 'cellared and bottled by',
  'packed by', 'cellared by', 'blended and bottled by', 'distilled and bottled by',
];

function stripBottlerPrefix(text) {
  if (!text) return '';
  let result = text.trim();
  for (const prefix of BOTTLER_PREFIXES) {
    const regex = new RegExp('^' + prefix + '\\s*', 'i');
    if (regex.test(result)) {
      result = result.replace(regex, '').trim();
      break;
    }
  }
  return result;
}

// Normalize text for word-order-independent comparison
// Sorts words alphabetically so "11.5% ALC. BY VOL." matches "ALC. 11.5% BY VOL."
function normalizeForComparison(str) {
  if (!str) return '';
  return str.toUpperCase()
    .replace(/[^\w\d%]/g, ' ')     // Keep alphanumeric and % only (strip periods)
    .replace(/(\d)([A-Z])/g, '$1 $2')  // Add space between digit and letter: "750ML" -> "750 ML"
    .replace(/([A-Z])(\d)/g, '$1 $2')  // Add space between letter and digit: "ML750" -> "ML 750"
    .replace(/%([A-Z])/g, '% $1')      // Add space after %: "15%ALC" -> "15% ALC"
    .replace(/\s+/g, ' ')          // Collapse whitespace
    .trim()
    .split(' ')
    .filter(w => w.length > 0)
    .sort()                        // Sort words for order-independent comparison
    .join(' ');
}

// Check if values match
function valuesMatch(fieldKey, appValue, ocrValue) {
  if (!appValue || !ocrValue) return true; // Can't compare if missing

  // Alcohol content: word-order-independent comparison
  // "11.5% ALC. BY VOL." should match "ALC. 11.5% BY VOL."
  if (fieldKey === 'alcoholContent') {
    return normalizeForComparison(appValue) === normalizeForComparison(ocrValue);
  }

  // Net contents: also word-order-independent
  if (fieldKey === 'netContents') {
    return normalizeForComparison(appValue) === normalizeForComparison(ocrValue);
  }

  // Bottler/importer name: strip prefixes before comparison
  // "IMPORTED BY ABC IMPORTS" should match "ABC IMPORTS"
  if (fieldKey === 'bottlerName') {
    const normApp = normalizeText(stripBottlerPrefix(appValue));
    const normOcr = normalizeText(stripBottlerPrefix(ocrValue));
    // Check if one contains the other (handles partial matches like "ABC" vs "ABC INC")
    return normApp === normOcr || normOcr.includes(normApp) || normApp.includes(normOcr);
  }

  // Case-insensitive for everything else (strict word order)
  return normalizeText(appValue) === normalizeText(ocrValue);
}

// Render the verification results
function renderResults(appData, extraction) {
  const container = document.getElementById('results');
  const fields = extraction.fields || {};

  // Store globally for toggle handlers and reset
  currentAppData = appData;
  currentVerificationData = extraction;

  // Get category-specific configs
  const category = getProductCategory(appData.classTypeCode);
  const mandatoryConfig = getMandatoryChecks(category.key, appData);
  const fieldConfig = getFieldConfig(category.key);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // MANDATORY PRESENCE CHECKS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mandatoryChecks = [];
  for (const config of mandatoryConfig) {
    const detected = checkMandatoryElement(config.key, fields, config.expectedValue);
    // Get image URL if available (governmentWarning has the back label crop)
    const fieldData = fields[config.key] || fields.governmentWarning || {};
    mandatoryChecks.push({
      key: config.key,
      label: config.label,
      detected,
      imageUrl: fieldData.imageUrl || '',
      alertIfMissing: config.alertIfMissing || null,
      expectedValue: config.expectedValue || null,
    });
  }
  const allMandatoryPass = mandatoryChecks.every(c => c.detected);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // FIELD VERIFICATION CHECKS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fieldChecks = [];
  currentChecks = fieldChecks; // Store reference for toggle handlers
  const fieldIssues = [];

  for (const [fieldKey, config] of Object.entries(fieldConfig)) {
    const fieldData = fields[fieldKey] || {};
    const ocrValue = fieldData.text || '';
    const ocrScore = fieldData.ocrScore;
    const imageUrl = fieldData.imageUrl || '';
    const side = fieldData.side || 'front';

    // Special handling for bottler fields
    // For imports: applicantName IS the US importer (per TTB rules)
    // For domestic: use dbaName if present, otherwise applicantName
    let appValue;
    if (fieldKey === 'bottlerName') {
      const isImport = isImportedProduct(appData.originCode);
      if (isImport) {
        // Imports: verify the US importer name (applicantName)
        // dbaName on imports often contains foreign producer (optional label info)
        appValue = appData.applicantName || '';
      } else {
        // Domestic: use dbaName (trade name) if present, else applicantName
        appValue = appData.dbaName || appData.applicantName || '';
      }
    } else if (fieldKey === 'bottlerAddress') {
      appValue = appData.applicantAddress || '';
    } else {
      appValue = appData[fieldKey] || '';
    }

    // Skip optional fields if applicant didn't declare them
    if (config.optional && !appValue) {
      continue;
    }

    const match = valuesMatch(fieldKey, appValue, ocrValue);

    // Check for ABV format warning (TTB requires "alc/vol" not "ABV")
    let warning = null;
    if (fieldKey === 'alcoholContent' && ocrValue && /\bABV\b/i.test(ocrValue)) {
      warning = 'Label uses "ABV" format. TTB requires "alc/vol" or "alc. by vol."';
    }

    // Override label for bottler fields on imports
    let fieldLabel = config.label;
    if (fieldKey === 'bottlerName' && isImportedProduct(appData.originCode)) {
      fieldLabel = 'Importer';
    } else if (fieldKey === 'bottlerAddress' && isImportedProduct(appData.originCode)) {
      fieldLabel = 'Importer Address';
    }

    fieldChecks.push({
      key: fieldKey,
      label: fieldLabel,
      order: config.order,
      appValue,
      ocrValue,
      ocrScore,
      imageUrl,
      side,
      match,
      optional: config.optional || false,
      warning,
    });

    if (!match) {
      const { shortDesc, fullDesc } = generateIssueExplanation(fieldKey, appValue, ocrValue);
      fieldIssues.push({
        field: fieldKey,
        label: config.label,
        appValue,
        ocrValue,
        shortDesc,
        fullDesc,
      });
    }
  }

  fieldChecks.sort((a, b) => a.order - b.order);
  const allFieldsPass = fieldIssues.length === 0;
  const allPass = allMandatoryPass && allFieldsPass;

  // Build HTML
  const frontSrc = appData.labelImages?.front ? TTB_IMG_BASE + appData.labelImages.front : null;
  const backSrc = appData.labelImages?.back ? TTB_IMG_BASE + appData.labelImages.back : null;

  // Use fanciful name as main heading, or brand name if no fanciful
  const mainName = appData.fancifulName || appData.brandName || 'Unknown';
  const subName = appData.fancifulName ? appData.brandName : null;

  let html = `
    <div class="status-banner ${allPass ? 'status-pass' : 'status-fail'}">
      <div class="status-left">
        <div class="status-icon">${allPass ? 'âœ“' : 'âš '}</div>
        <div class="status-text">
          <h3>${allPass ? 'Instant Approval' : 'Potential Issues'}</h3>
          <div class="status-count" id="statusCount">${allPass
            ? 'Ready to approve'
            : `${fieldIssues.length + mandatoryChecks.filter(c => !c.detected).length} to verify`}</div>
        </div>
      </div>
      <div class="draft-box" id="draftBox" style="${allPass ? 'display:none' : 'display:none'}">
        <div class="draft-sidebar">
          <span class="draft-label">Revision<br>Notes</span>
          <div id="draftAction"></div>
        </div>
        <div class="draft-content" id="draftText"></div>
      </div>
    </div>

    <div class="result-header">
      <div class="header-top">
        <div class="header-left">
          <div class="fanciful-name">${mainName}</div>
          <div class="product-type-pill ${category.class}">${category.name}</div>
          <div class="origin-pill ${isImportedProduct(appData.originCode) ? 'pill-foreign' : 'pill-domestic'}">${isImportedProduct(appData.originCode) ? 'Imported' : 'Domestic'}</div>
        </div>
        <div class="ttb-id"><a href="#" class="reset-link" onclick="resetToAI(); return false;">â†º Reset</a> / ID: <span>${appData.ttbId}</span></div>
      </div>
      ${subName ? `<div class="brand-name">${subName}</div>` : ''}
    </div>
  `;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // MANDATORY ELEMENTS SECTION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  html += `
    <hr class="section-divider">
    <div class="mandatory-section">
      <table class="mandatory-table">
        <thead>
          <tr>
            <th>Field</th>
            <th>Expected</th>
            <th>On Label</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
  `;

  for (const check of mandatoryChecks) {
    // Get saved review state from localStorage
    const storeKey = `review_${appData.ttbId}_mandatory_${check.key}`;
    const savedState = localStorage.getItem(storeKey) || (check.detected ? 'ok' : 'reviewing');

    // Determine row class based on saved state
    let rowClass = '';
    if (savedState === 'reject') {
      rowClass = 'row-mismatch';
    } else if (savedState === 'reviewing') {
      rowClass = 'row-warning';
    }

    // Build requirement cell content (status + alert note)
    let requirementContent = '';
    if (check.detected) {
      // Scenario 1: AI auto-detected OK
      if (savedState === 'reviewing') {
        requirementContent = '<span class="mandatory-status ai-ok">Requirement auto-detected ok</span>';
      } else if (savedState === 'reject') {
        requirementContent = '<span class="mandatory-status rejected">âœ— Override: Agent found issue</span>';
      } else {
        requirementContent = '<span class="mandatory-status">âœ“ Auto-detected</span>';
      }
    } else {
      // Scenario 2: AI flagged an issue
      let statusText, statusClass;
      if (savedState === 'ok') {
        statusText = 'âœ“ Agent verified';
        statusClass = '';
      } else if (savedState === 'reject') {
        statusText = 'âœ— Agent confirmed issue';
        statusClass = 'rejected';
      } else {
        statusText = 'âš  Agent verification needed';
        statusClass = 'missing';
      }
      requirementContent = `<span class="mandatory-status ${statusClass}">${statusText}</span>`;
      if (check.alertIfMissing && savedState !== 'ok') {
        requirementContent += `<div class="alert-note">${check.alertIfMissing}</div>`;
      }
    }

    // Build on-label cell content (image only)
    let onLabelContent = '';
    if (check.imageUrl) {
      // AI extracted an image
      onLabelContent = `<img src="${check.imageUrl}" class="ocr-image zoomable" alt="${check.label}" onclick="openLightbox(this.src)">`;
    } else if (!check.detected && (backSrc || frontSrc)) {
      // No extraction, show thumbnail link to full label for manual review
      onLabelContent = `<a href="${backSrc || frontSrc || '#'}" onclick="openLightbox('${backSrc || frontSrc || ''}'); return false;">
        <img src="${backSrc || frontSrc}" class="verify-thumb" alt="Click to verify on label">
      </a>`;
    }

    html += `
      <tr class="${rowClass}" data-field="mandatory_${check.key}">
        <td>
          <div class="field-cell">
            <span class="field-name">${check.label}</span>
            <div class="toggle-btns">
              <button data-state="reviewing" class="${savedState === 'reviewing' ? 'active-reviewing' : ''}" title="Needs Review">?</button>
              <button data-state="ok" class="${savedState === 'ok' ? 'active' : ''}" title="OK">âœ“</button>
              <button data-state="reject" class="${savedState === 'reject' ? 'active-correct' : ''}" title="Needs Correction">âœ—</button>
            </div>
          </div>
        </td>
        <td>${requirementContent}</td>
        <td>${onLabelContent}</td>
        <td class="row-status ${
          !check.detected
            ? (savedState === 'reviewing' ? 'status-flagged' : (savedState === 'reject' ? 'status-rejected' : 'status-ok'))
            : 'status-none'
        }" data-ai-flagged="${!check.detected}">
          ${!check.detected ? `
            <div class="status-icon">${savedState === 'reviewing' ? 'âš ' : (savedState === 'reject' ? 'âœ—' : 'âœ“')}</div>
            <div class="ai-note">${savedState === 'reject' ? 'Missing' : (savedState === 'ok' ? 'Verified<br>OK' : 'Needs<br>review')}</div>
          ` : ''}
        </td>
      </tr>
    `;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // FIELD VERIFICATION ROWS (continuing same table)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  for (const check of fieldChecks) {
    const ocrScore = check.ocrScore;
    const hasValidScore = typeof ocrScore === 'number' && !isNaN(ocrScore);
    const hasReliableBox = hasValidScore && ocrScore >= 0.50;  // Bounding box likely correct

    // Get saved review state from localStorage
    const storeKey = `review_${appData.ttbId}_${check.key}`;
    const savedState = localStorage.getItem(storeKey) || (check.match ? 'ok' : 'reviewing');

    // Build EXPECTED column: app value + status text below
    const appValue = check.appValue && !/^\(SEE\s+\w+\s+LABEL\)$/i.test(check.appValue) ? check.appValue : 'â€”';
    let statusText = '';
    let statusClass = '';
    if (check.match) {
      // Scenario 1: AI auto-detected OK
      if (savedState === 'reviewing') {
        statusText = 'Requirement auto-detected ok';
        statusClass = 'ai-ok';
      } else if (savedState === 'reject') {
        statusText = 'âœ— Override: Agent found issue';
        statusClass = 'rejected';
      } else {
        statusText = 'âœ“ Auto-detected';
        statusClass = '';
      }
    } else {
      // Scenario 2: AI flagged an issue
      if (savedState === 'ok') {
        statusText = 'âœ“ Agent verified';
        statusClass = '';
      } else if (savedState === 'reject') {
        statusText = 'âœ— Agent confirmed issue';
        statusClass = 'rejected';
      } else {
        statusText = 'âš  Agent verification needed';
        statusClass = 'missing';
      }
    }
    const declaredContent = `${appValue}<div class="field-status ${statusClass}" data-field-key="${check.key}" data-ai-ok="${check.match}">${statusText}</div>`;

    // Build ON LABEL column: image only
    let onLabelContent = '';
    const isBackField = ['bottlerName', 'bottlerAddress'].includes(check.key);
    const primarySrc = isBackField ? (backSrc || frontSrc) : (frontSrc || backSrc);
    const secondarySrc = isBackField ? frontSrc : backSrc;
    const hasBothLabels = frontSrc && backSrc;

    if (check.imageUrl) {
      // AI extracted an image
      onLabelContent = `<img src="${check.imageUrl}" class="ocr-image zoomable" alt="${check.label}" onclick="openLightbox(this.src)">`;
    } else if (primarySrc) {
      // No extraction - show thumbnail(s) for manual review
      onLabelContent = `<a href="${primarySrc}" onclick="openLightbox('${primarySrc}'); return false;">
        <img src="${primarySrc}" class="verify-thumb" alt="${isBackField ? 'back' : 'front'}">
      </a>`;
      if (hasBothLabels && secondarySrc) {
        onLabelContent += `<a href="${secondarySrc}" onclick="openLightbox('${secondarySrc}'); return false;" style="margin-left:4px;">
          <img src="${secondarySrc}" class="verify-thumb" alt="${isBackField ? 'front' : 'back'}">
        </a>`;
      }
    }

    // Determine row class based on saved state
    let rowClass = '';
    if (savedState === 'reject') {
      rowClass = 'row-mismatch';
    } else if (savedState === 'reviewing') {
      rowClass = 'row-warning';
    }

    html += `
      <tr class="${rowClass}" data-field="${check.key}">
        <td>
          <div class="field-cell">
            <span class="field-name">${check.label}</span>
            <div class="toggle-btns">
              <button data-state="reviewing" class="${savedState === 'reviewing' ? 'active-reviewing' : ''}" title="Needs Review">?</button>
              <button data-state="ok" class="${savedState === 'ok' ? 'active' : ''}" title="OK">âœ“</button>
              <button data-state="reject" class="${savedState === 'reject' ? 'active-correct' : ''}" title="Needs Correction">âœ—</button>
            </div>
          </div>
        </td>
        <td class="app-value">${declaredContent}</td>
        <td>${onLabelContent}</td>
        <td class="row-status ${
          !check.match
            ? (savedState === 'reviewing' ? 'status-flagged' : (savedState === 'reject' ? 'status-rejected' : 'status-ok'))
            : 'status-none'
        }" data-ai-flagged="${!check.match}">
          ${!check.match ? `
            <div class="status-icon">${savedState === 'reviewing' ? 'âš ' : (savedState === 'reject' ? 'âœ—' : 'âœ“')}</div>
            <div class="ai-note">${savedState === 'reject' ? 'Mismatch' : (savedState === 'ok' ? 'Verified<br>OK' : 'Needs<br>review')}</div>
          ` : ''}
        </td>
      </tr>
    `;
  }

  html += `
        </tbody>
      </table>
    </div>
  `;

  // Label images
  html += `
    <div class="labels-section" id="labels">
      <h4>Label Images</h4>
      <div class="labels-grid">
        <div class="label-card">
          <div class="label-card-title">Front</div>
          ${frontSrc
            ? `<img src="${frontSrc}" alt="Front">`
            : '<div class="no-image">No image</div>'}
        </div>
        <div class="label-card">
          <div class="label-card-title">Back</div>
          ${backSrc
            ? `<img src="${backSrc}" alt="Back">`
            : '<div class="no-image">No image</div>'}
        </div>
      </div>
    </div>

    <div class="footer">
      TTB Label Verification Tool â€” AI-assisted compliance review
    </div>
  `;

  container.innerHTML = html;

  // Add click handlers for toggle buttons
  container.querySelectorAll('.toggle-btns button').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const state = btn.dataset.state;
      const row = btn.closest('tr');
      const field = row.dataset.field;
      const storeKey = `review_${appData.ttbId}_${field}`;

      // Save to localStorage
      localStorage.setItem(storeKey, state);

      // Update button states
      const btns = btn.parentElement.querySelectorAll('button');
      btns.forEach(b => b.classList.remove('active', 'active-reviewing', 'active-correct'));
      if (state === 'reject') {
        btn.classList.add('active-correct');
      } else if (state === 'reviewing') {
        btn.classList.add('active-reviewing');
      } else {
        btn.classList.add('active');
      }

      // Update row styling
      row.classList.remove('row-mismatch', 'row-warning');
      if (state === 'reject') {
        row.classList.add('row-mismatch');
      } else if (state === 'reviewing') {
        row.classList.add('row-warning');
      }

      // Hide/show alert-note based on state (for mandatory elements)
      const alertNote = row.querySelector('.alert-note');
      if (alertNote) {
        alertNote.style.display = (state === 'ok') ? 'none' : '';
      }

      // Update status text based on state
      const isMandatoryRow = field.startsWith('mandatory_');

      if (isMandatoryRow) {
        // Mandatory element: update the requirement cell (column 2)
        const mandatoryStatus = row.querySelector('td:nth-child(2) .mandatory-status');
        const statusCell = row.querySelector('.row-status');
        const aiThoughtOk = statusCell && statusCell.dataset.aiFlagged === 'false';
        if (mandatoryStatus) {
          mandatoryStatus.classList.remove('missing', 'ai-ok', 'rejected');
          if (aiThoughtOk) {
            // Scenario 1: AI auto-detected OK
            if (state === 'ok') {
              mandatoryStatus.textContent = 'âœ“ Auto-detected';
            } else if (state === 'reject') {
              mandatoryStatus.textContent = 'âœ— Override: Agent found issue';
              mandatoryStatus.classList.add('rejected');
            } else {
              mandatoryStatus.textContent = 'Requirement auto-detected ok';
              mandatoryStatus.classList.add('ai-ok');
            }
          } else {
            // Scenario 2: AI flagged an issue
            if (state === 'ok') {
              mandatoryStatus.textContent = 'âœ“ Agent verified';
            } else if (state === 'reject') {
              mandatoryStatus.textContent = 'âœ— Agent confirmed issue';
              mandatoryStatus.classList.add('rejected');
            } else {
              mandatoryStatus.textContent = 'âš  Agent verification needed';
              mandatoryStatus.classList.add('missing');
            }
          }
        }
      } else {
        // Field verification: update field-status in Declared column
        const fieldStatus = row.querySelector('.field-status');
        if (fieldStatus) {
          const aiThoughtOk = fieldStatus.dataset.aiOk === 'true';
          fieldStatus.classList.remove('missing', 'ai-ok', 'rejected');
          if (aiThoughtOk) {
            // Scenario 1: AI auto-detected OK
            if (state === 'ok') {
              fieldStatus.textContent = 'âœ“ Auto-detected';
            } else if (state === 'reject') {
              fieldStatus.textContent = 'âœ— Override: Agent found issue';
              fieldStatus.classList.add('rejected');
            } else {
              fieldStatus.textContent = 'Requirement auto-detected ok';
              fieldStatus.classList.add('ai-ok');
            }
          } else {
            // Scenario 2: AI flagged an issue
            if (state === 'ok') {
              fieldStatus.textContent = 'âœ“ Agent verified';
            } else if (state === 'reject') {
              fieldStatus.textContent = 'âœ— Agent confirmed issue';
              fieldStatus.classList.add('rejected');
            } else {
              fieldStatus.textContent = 'âš  Agent verification needed';
              fieldStatus.classList.add('missing');
            }
          }
        }
      }

      // Update status indicator (only for AI-flagged rows)
      const statusCell = row.querySelector('.row-status');
      if (statusCell && statusCell.dataset.aiFlagged === 'true') {
        const isMandatory = field.startsWith('mandatory_');
        const rejectLabel = isMandatory ? 'Missing' : 'Mismatch';
        statusCell.classList.remove('status-flagged', 'status-ok', 'status-rejected');
        if (state === 'reject') {
          statusCell.classList.add('status-rejected');
          statusCell.innerHTML = `<div class="status-icon">âœ—</div><div class="ai-note">${rejectLabel}</div>`;
        } else if (state === 'reviewing') {
          statusCell.classList.add('status-flagged');
          statusCell.innerHTML = '<div class="status-icon">âš </div><div class="ai-note">Needs<br>review</div>';
        } else {
          statusCell.classList.add('status-ok');
          statusCell.innerHTML = '<div class="status-icon">âœ“</div><div class="ai-note">Verified<br>OK</div>';
        }
      }

      // Update revision notes with corrected fields
      updateDraftBox();
    });
  });

  // Initialize draft box state
  updateDraftBox();
}

// Fetch JSON from an API endpoint
async function fetchJson(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) return null;
    return await response.json();
  } catch (e) {
    return null;
  }
}

// Fetch data for a TTB ID from both APIs
async function fetchAllData(ttbId) {
  const [applicant, verification] = await Promise.all([
    fetchJson(getTtbShardedPath(ttbId)),           // TTB external: applicant data
    fetchJson(getVerificationResultPath(ttbId)),   // Our API: AI results
  ]);
  return { applicant, verification };
}

// Handle incoming message from agent view
async function handleVerification(appData) {
  const waiting = document.getElementById('waitingState');
  const notProcessed = document.getElementById('notProcessedState');
  const results = document.getElementById('results');

  // Hide all states
  waiting.classList.add('hidden');
  notProcessed.classList.remove('visible');
  results.classList.remove('visible');

  // Fetch data from both APIs
  const { applicant, verification } = await fetchAllData(appData.ttbId);

  // Use applicant API data if available, otherwise fall back to postMessage data
  const declaredData = applicant || appData;

  // Need verification results to show anything
  if (!verification || !verification.fields) {
    // Not processed
    notProcessed.classList.add('visible');
  } else {
    // Add image URLs for each field (PNG files, not base64)
    const fieldsWithImages = { ...verification.fields };
    for (const fieldKey of Object.keys(fieldsWithImages)) {
      fieldsWithImages[fieldKey].imageUrl = getExtractionImagePath(appData.ttbId, fieldKey);
    }

    // Show results
    results.classList.add('visible');
    renderResults(declaredData, { fields: fieldsWithImages });
  }
}

window.addEventListener('message', async (e) => {
  if (e.data && e.data.source === 'agent-view' && e.data.section === 'ai-check') {
    handleVerification(e.data);
  }
});

// Test mode: load with ?test=ttbId or ?test=1 (first app)
async function initTestMode() {
  const params = new URLSearchParams(window.location.search);
  const testParam = params.get('test');
  if (!testParam) return;

  // Load applications data
  try {
    const script = document.createElement('script');
    script.src = 'ttb-external/data/applications.js';
    script.onload = async () => {
      if (typeof applications === 'undefined') return;

      let app;
      if (testParam === '1' || testParam === 'true') {
        app = applications[0];
      } else {
        app = applications.find(a => a.ttbId === testParam);
      }

      if (app) {
        // Build the message data structure
        const appData = {
          ttbId: app.ttbId,
          brandName: app.brandName,
          fancifulName: app.fancifulName,
          alcoholContent: app.alcoholContent,
          netContents: app.netContents,
          classTypeCode: app.classTypeCode,
          classTypeDesc: app.classTypeDesc,
          qualifications: app.qualifications,
          labelImages: {
            front: app.front_image_path,
            back: app.back_image_path
          }
        };
        handleVerification(appData);
      }
    };
    document.head.appendChild(script);
  } catch (e) {
    console.error('Test mode failed:', e);
  }
}

// Reset all review states to AI defaults
function resetToAI() {
  if (!currentAppData) return;
  const ttbId = currentAppData.ttbId;

  // Remove all localStorage keys for this TTB ID
  const keysToRemove = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith(`review_${ttbId}_`)) {
      keysToRemove.push(key);
    }
  }
  keysToRemove.forEach(key => localStorage.removeItem(key));

  // Re-render with fresh AI defaults
  renderResults(currentAppData, currentVerificationData);
}

// Copy draft text to clipboard
function copyDraftText() {
  const draftEl = document.getElementById('draftText');
  if (draftEl) {
    navigator.clipboard.writeText(draftEl.textContent).then(() => {
      const btn = document.querySelector('.copy-btn');
      const originalText = btn.innerHTML;
      btn.innerHTML = 'âœ“ Copied';
      setTimeout(() => { btn.innerHTML = originalText; }, 1500);
    });
  }
}

// Lightbox for image zoom
function openLightbox(imgSrc) {
  const lb = document.getElementById('lightbox');
  const lbImg = document.getElementById('lb-img');
  lbImg.src = imgSrc;
  lb.classList.add('open');
}

function closeLightbox() {
  document.getElementById('lightbox').classList.remove('open');
}

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeLightbox();
});

// Initialize test mode on load
initTestMode();
</script>
</body>
</html>
